"""
10-8 边界匹配符
"""
# 边界匹配
import re
# 验证这个QQ号是否符合要求。
# 要求：4-8位
qq = '100001'
r = re.findall('\d{4,8}', qq)
print(r)
# ['100001']
# 4-8位内成功匹配

qq = '101'
r = re.findall('\d{4,8}', qq)
print(r)
# []
# 小于4位成功匹配

qq = '100000001'
r = re.findall('\d{4,8}', qq)
print(r)
# ['10000000']
# 大于8位不能正确匹配
# 本质原因在于这个正则表达式只是在给定表达式中进行寻找，并不是完整地匹配字符串。
# 边界匹配可以完整地匹配字符串。

# 边界匹配
qq = '100000001'
r = re.findall('^\d{4,8}$', qq)
print(r)
# []
# 完整的字符串是9位，不在{4,8}范围内，所以不符合正则表达式。
# ^ 从字符串开始的位子开始匹配
# $ 从字符串末尾的位子开始匹配
# 一前一后就可以匹配完整的字符串

# 如何理解1：
qq = '100000001'
r = re.findall('000', qq)
print(r)
# ['000', '000']

r = re.findall('^000', qq)
print(r)
# []
# 如果从字符串前面开始匹配，不符合正则表达式，因为字符串前面三位是100，不是000。

r = re.findall('000$', qq)
print(r)
# []
# 如果从字符串后面开始匹配，任然不符合正则表达式，因为字符串最后三位是001，不是000。
# $ 是占位符，代表字符串的末尾，所以从末尾倒数往前匹配。

# 如何理解2：
# No.1
qq = '100000001'
r = re.findall('^\d{4,8}', qq)
print(r)
# ['10000000']

# No.2
r = re.findall('\d{4,8}$', qq)
print(r)
# ['00000001']

# No.3
r = re.findall('^\d{4,8}$', qq)
print(r)
# []

# No.3 包括 No.1 和 No.2 这两个步骤。
# No.1 和 No.2 的结果不匹配，所以不符合正则表达式。
