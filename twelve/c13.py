"""
12-13 装饰器 六
"""

# 装饰器具体体现了什么思想？
# 我们日常编程中什么情况可能会用到装饰器？

# 装饰器最基本的思想：
# 从代码稳定性的角度：如果我们想对某一个被封装的单元，比如说函数做出代码上的修改，我们可以不去改变具体的实现，而是通过装饰器这样一种形式来改变函数的行为。
# 从代码的复用性的角度：比如说打印时间的功能是新增的逻辑，现在把逻辑封装成装饰器。凡是需要打印时间的函数通过装饰器的@符号把它强行加在函数上面。

# 如果我们想一个函数增加一个功能，然后也不想改变函数内部的实现，怎么办？
# 普通的函数是无法解决这个问题。为什么？
# 无论如何f1和f2都要调用这个普通函数，这样违反了开闭原则。
# 这个时候装饰器的优势就体现出来了。

# 打印时间有什么用？
# 在函数执行和结束的时候打印时间可以查看函数的执行效率。

# Flask 框架里定义的控制器：
# Flask 是一个web开发框架。

@api.route('/get', method=['GET'])
def test_javascript_http():
    p = request.args.get('name')
    return p, 200

@api.route('/get', method=['GET'])
@auth.login_required
def get_psw():
    p = request.args.get('psw')
    r = generate_password_hash(p)
    return 'aaaaaa', 200

# 如果不添加装饰器api.route, 它只是一个简单的函数。
# 添加装饰器以后，它就变成了控制器。
# 这个装饰器可以访问控制器URL地址，称为'GET'。
# 还可以指定访问http的方法。
# 这个装饰器还可以用在别的函数上。
# @api.route装饰器内部代码很复杂，如果直接把这个复杂的装饰器直接加载函数里不可行。
# 这个时候体现出装饰器的优势。
# 一个函数可以有多个装饰器。

# 有些接口是面向大众的，但有些接口不是任何人都可以访问。
# 图书信息服务谁都可以访问。
# 有一些接口，比如说我们删除数据的接口是不能给所有人访问。
# 接口分为两类:
# 面向大众的
# 受保护的

# 在需要验证用户身份的接口上装上@auth.login_required装事情, 这个函数就变成了需要验证才能访问的控制器.

