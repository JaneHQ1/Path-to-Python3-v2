"""
12-8 装饰器 一
"""

# 装饰器是 Python 高阶知识里最有用，用得最多的知识点是。
# 装饰器不是 Python 所独有的。
# 装饰器是一种设定模式。
# C# 里特性类似 Python 装饰器。
# Java 注解类似 Python 装饰器。
# 要理解装饰器得使用场景，装饰器能够帮助我们解决什么问题。
# 经常出现这样的现象：能看懂装饰器的资料，自己使用的时候突然忘记装饰器是什么，想起来装饰器是什么以后，不知道怎么使用。
# 逐渐演进，最后推出装饰器的定义和作用。

import time


def f1():
    # print(time.time())
    print('This is a function')

f1()

# 1550485702.4683478   Unix 时间戳
# This is a function

# Unix 时间戳 (Unix timestamp)
# 定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。
# 数据库里存时间戳用来表示时间。

# 如果有多个函数，每个函数都需要带有打印执行时间的功能，我们是否需要在每个函数里都要加上 print(time.time())？
# 它违反了原则：如果需求产生变更的时候，尽量不要改变函数，对象或者是类下面具体的实现。
# 应该通过扩展函数，或者类来解决需求变更。
# 开闭原则：对修改是封闭的，对扩展是开放的。
# 专门定义一个函数用来打印时间：


def f2():
    print('This is a function')


def print_current_time(func):
    # 函数可以作为另外一个函数的参数传递进来。
    print(time.time())
    func()


print_current_time(f1)
print_current_time(f2)

# This is a function
# 1550486416.938671
# This is a function
# 1550486416.938671
# This is a function

# f1 和 f2 都可以在原来的功能基础上新增加打印时间的功能。
# 优点：没有违反修改是封闭的原则。巧妙利用函数式编程的特性，把函数传到例外一个函数里，在另外一个函数里通过打印时间完成需求变更。
# 缺点：打印时间这个新增加的需求属于每个函数本身的，并不属于新增加的函数。我们强行在每个函数之前加入打印时间，并没有体现函数本身的特性。
# 和下面的代码没有区别：
print(time.time())
f1()
print(time.time())
f2()

# 有没有办法让我们新添加的业务逻辑依然和老函数绑定在一起？
# 体现出是对原来函数功能增加，同时不去更改函数内部的实现？
# 这就是装饰器要去解决的问题。

# 通过一步步地推倒，重点是要知道装饰器的优点。



